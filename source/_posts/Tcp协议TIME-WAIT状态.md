---
title: Tcp协议TIME_WAIT状态
tags: tcp/ip
abbrlink: d4a8876c
date: 2017-08-13 21:00:20
---

## TIME_WAIT状态

### TIME_WAIT状态何时发生？ 状态持续时间为多久？
TIME_WAIT状态在TCP4次挥手是产生。当客户端收到服务端返回FIN信号时，进入TIME_WAIT状态并且向服务端返回ACK，告知服务端我已经收到你的FIN信息。

TIME_WAIT状态的时间是最长分节时间（maximun segment lifetime, MSL）的两倍， 有时候称之为2MSL。 最长分节时间是指，一次TCP报文在服务端和客户端之前传送存活的最长时间，若超过这个时间，该报文仍未到达目的地，则可认为该报文已被丢弃。

最长分节时间一般由ip报文的TTL标识，TTL代表一个ip报文传递时通过一个ip报文的最大跳数（255），ip报文每经过一个路由器，TTL会减1，当TTL为0时，路由器会将该报文丢弃。

### 为何需要该状态？  该状态设置的时间为何是2MSL?
<!-- more -->

该状态存在有两个理由。
（1） 可靠地实现TCP全双工连接的终止
这句话比较拗口。 意思是在在四次挥手时，如果最后的分节报文丢失（ip报文会丢），客户端也能够正常处理结果，而不会出错。

有这样一种情况。四次挥手时，客户端最后发送给服务端的ACK丢失时， 服务端会认为客户端没收到自己的FIN，然后会重传FIN。此时客户端其实已经收到过第一个FIN了，如果客户端不维护状态信息，它将返回一个RST分节，该分节将会被服务端解析成错误。

因此如果tcp想可靠地关闭连接，那就要能够处理四次挥手时任何一个分节数据丢失的情况。

（2） 保证老的重复分节已经在网络中消失。
假设a和b之间建立了一个连接A1-B1， 连接关闭后，a和b之间又建立了连接A2-B2。 但连接A1-B1关闭后，可能有些报文数据由于网络原因（如发生了路由循环）延迟了一段时间后，又到底了a或者b。但此时已经是A2-B2连接，该报文是无效的。

 设置TIME_WAIT时间为2MSL，就保证了建立新的连接时，之前的连接报文在网络中都已经失效了。
